#include <stdio.h>
#include <stdlib.h>
#include <assert.h>
#include <sys/queue.h>

#include "../rx_log.h"
#include "../util_attribute.h"
#include "log_raw.h"
#include "log_filter.h"

__unused static struct log_data_v *
get_decode(struct log_data_v *v0)
{
	struct log_data_v *v;

	if (v0 == NULL)
		return NULL;
	if (v0->type == FRAME_TYPE_DECODE)
		return v0;

	TAILQ_FOREACH(v, &v0->kv->vh, chain) {
		if (v->type == FRAME_TYPE_DECODE)
			return v;
	}

	return NULL;
}

static int
log_update_kv(struct log_store *ls)
{
	struct log_data_kv *kv, *block_kv;
	struct log_data_v *v, *vd;
	bool fec_recoverble;
	int n_fec = 0;

	/* Update ethernet frame counts in block_kv */
	TAILQ_FOREACH(kv, &ls->block_kvh, chain) {
		kv->has_ethernet_frame = false;
		kv->has_lost_frame = false;
		kv->has_fec_frame = false;
		kv->n_ethernet_frame = 0;
		kv->n_h265_frame = 0;
		TAILQ_FOREACH(v, &kv->vh, block_chain) {
			if (v->filtered)
				continue;
			if (v->type != FRAME_TYPE_INET6)
				continue;
			kv->has_ethernet_frame = true;
			kv->n_ethernet_frame++;
		}
		if (kv->n_ethernet_frame < ls->fec_k)
			kv->has_lost_frame = true;
	}

	/* Update seq counts */
	TAILQ_FOREACH(kv, &ls->kvh, chain) {
		kv->has_ethernet_frame = false;
		kv->has_lost_frame = false;
		kv->has_fec_frame = false;
		kv->n_ethernet_frame = 0;
		kv->n_h265_frame = 0;
		vd = NULL;
		block_kv = NULL;
		TAILQ_FOREACH(v, &kv->vh, chain) {
			if (!block_kv && v->block_kv)
				block_kv = v->block_kv;
			if (v->filtered)
				continue;
			if (v->type == FRAME_TYPE_INET6) {
				kv->has_ethernet_frame = true;
				kv->n_ethernet_frame++;
			}
			if (v->type == FRAME_TYPE_DECODE) {
				vd = v;
			}
		}
		assert(block_kv);
		if (vd == NULL) {
			/* no decoded frame in original data */
			if (kv->key < ls->fec_k) {
				kv->has_lost_frame = true;
				block_kv->has_lost_frame = true;
			}
		}
		else if (kv->has_ethernet_frame) {
			/* decode is not affected. */
			vd->filtered = false;
			kv->n_h265_frame++;
			block_kv->n_h265_frame++;
		}
		else if (vd->block_kv->n_ethernet_frame >= ls->fec_k) {
			/* the frame can be regenerated by FEC */
			kv->has_fec_frame = true;
			block_kv->has_fec_frame = true;

			vd->filtered = false;
			kv->n_h265_frame++;
			block_kv->n_h265_frame++;
			n_fec++;
		}
		else {
			/* Can't apply FEC, the frame is lost */
			vd->filtered = true;
			kv->has_lost_frame = true;
			block_kv->has_lost_frame = true;
		}
	}

	return n_fec;
}

int
log_filter_reset(struct log_store *ls)
{
	struct log_data_kv *kv;
	struct log_data_v *v;
	int n_filtered = 0;

	TAILQ_FOREACH(kv, &ls->kvh, chain) {
		TAILQ_FOREACH(v, &kv->vh, chain) {
			v->filtered = false;
		}
	}

	return 0;
}

int
log_filter_dbm(struct log_store *ls, int8_t cut_off)
{
	struct log_data_kv *seq_kv, *block_kv;
	struct log_data_v *v;
	int n_filtered = 0;
	int n_fec;

	TAILQ_FOREACH(seq_kv, &ls->kvh, chain) {
		TAILQ_FOREACH(v, &seq_kv->vh, chain) {
			if (v->type != FRAME_TYPE_INET6)
				continue;
			if (v->dbm == DBM_INVAL)
				continue;
			if (v->dbm <= cut_off) {
				v->filtered = true;
				n_filtered++;
			}
			else {
				v->filtered = false;
			}
		}
	}
	p_info("%d frames filtered.\n", n_filtered);
	n_fec = log_update_kv(ls);
	p_info("%d frames regenerated by FEC.\n", n_fec);

	return 0;
}
